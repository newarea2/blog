import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o,c as n,d as a}from"./app-f1b20077.js";const p={},s=a('<h1 id="pnpm-的优势" tabindex="-1"><a class="header-anchor" href="#pnpm-的优势" aria-hidden="true">#</a> pnpm 的优势</h1><h2 id="_1-速度更快" tabindex="-1"><a class="header-anchor" href="#_1-速度更快" aria-hidden="true">#</a> 1 速度更快</h2><blockquote><p>类似 maven</p></blockquote><p>之前依赖都是扁平化的安装在项目的 node_modules 文件夹中。如果尝试复制、删除项目，都要很长时间。若使用 pnpm，依赖存放在系统的某个位置 store，项目 node_modules 中的依赖仅仅是指向 store 中依赖的硬连接。</p><p>用 npm/yarn 的时候，如果 100 个项目都依赖 lodash，那么 lodash 很可能就被安装了 100 次，磁盘中就有 100 个地方写入了这部分代码。但在使用 pnpm 只会安装一次，磁盘中只有一个地方写入，后面再次使用都会直接使用 hardlink</p><h2 id="_2-更安全" tabindex="-1"><a class="header-anchor" href="#_2-更安全" aria-hidden="true">#</a> 2 更安全</h2><p>避免了npm中的依赖提升，使用 pnpm，项目 node_modules 下的依赖基本跟项目 package.json 声明的依赖一致。如果项目依赖了 a，a 依赖了 b，若是 npm，项目中可以使用 b，若是 pnmp，则项目中不能使用 b。</p><p><strong>使用 npm 的项目:</strong></p><p>执行 <code>npm i express</code>，node_modules 下不仅安装了 express，还有很多其他依赖，如 qs，在项目中可以使用 qs <code>const qs = require(&#39;qs&#39;)</code></p><figure><img src="https://blog-1320825986.cos.ap-nanjing.myqcloud.com/20230721/02.png" alt="02" tabindex="0" loading="lazy"><figcaption>02</figcaption></figure><p><strong>使用 pnpm 的项目：</strong></p><p>执行 <code>npm i express</code>，node_modules 下仅安装了 express 和 mini-types 的软连接，如果像上面那样在项目中使用 qs <code>const qs = require(&#39;qs&#39;)</code>，提示未安装</p><figure><img src="https://blog-1320825986.cos.ap-nanjing.myqcloud.com/20230721/01.png" alt="01" tabindex="0" loading="lazy"><figcaption>01</figcaption></figure><p>执行 <code>node src/index.js</code> 会报错</p><figure><img src="https://blog-1320825986.cos.ap-nanjing.myqcloud.com/20230721/03.png" alt="03" tabindex="0" loading="lazy"><figcaption>03</figcaption></figure><h2 id="_3-支持-monorepo" tabindex="-1"><a class="header-anchor" href="#_3-支持-monorepo" aria-hidden="true">#</a> 3 支持 monorepo</h2>',16),i=[s];function r(d,t){return o(),n("div",null,i)}const l=e(p,[["render",r],["__file","note.html.vue"]]);export{l as default};
